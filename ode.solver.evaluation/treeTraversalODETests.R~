TreeTraversalODE <- function(phy, Q_codon_array_vectored, liks.HMM, bad.likelihood=-100000, root.p) {

    nb.tip <- length(phy$tip.label)
    nb.node <- phy$Nnode

    anc <- unique(phy$edge[,1])
    TIPS <- 1:nb.tip

    comp <- numeric(nb.tip + nb.node)
    #Start the postorder traversal indexing lists by node number:
    for (i in seq(from = 1, length.out = nb.node)) {
        focal <- anc[i]
        desRows <- which(phy$edge[,1]==focal)
        desNodes <- phy$edge[desRows,2]
        v = rep(1, dim(liks.HMM)[2])

        for (desIndex in sequence(length(desRows))){
            yini <- liks.HMM[desNodes[desIndex],]
            times=c(0, phy$edge.length[desRows[desIndex]])
	    ##Change ODE solver here
            prob.subtree.cal.full <- lsoda(yini, times, func = "selacHMM", Q_codon_array_vectored, initfunc="initmod_selacHMM", dllname = "selac")

            ######## THIS CHECKS TO ENSURE THAT THE INTEGRATION WAS SUCCESSFUL ###########
            if(attributes(prob.subtree.cal.full)$istate[1] < 0){
                return(bad.likelihood)
            }else{
                prob.subtree.cal <- prob.subtree.cal.full[-1,-1]
            }
            ##############################################################################

            if(prob.subtree.cal[1]<0){
                return(bad.likelihood)
            }
            v <- v * prob.subtree.cal
        }
        comp[focal] <- sum(v)
        liks.HMM[focal,] <- v/comp[focal]
    }
    root.node <- nb.tip + 1L
    if (is.na(sum(log(liks.HMM[root.node,])))){
        return(bad.likelihood)
    }else{
        loglik <- -(sum(log(comp[-TIPS])) + log(sum(root.p * liks.HMM[root.node,])))
    }
    return(loglik)
}
